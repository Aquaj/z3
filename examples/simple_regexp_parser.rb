require "regexp_parser"

# Format generated by Regexp::Parser is not convenient at all,
# let's translate it into something more useful
class SimpleRegexpParser
  def initialize(str)
    @tree = Regexp::Parser.parse(str)
  end

  def sequence(*parts)
    parts = parts.select{|x| x[0] != :empty}
    case parts.size
    when 0
      [:empty]
    when 1
      parts[0]
    else
      while parts.size > 1
        parts.unshift [:seq, parts.shift, parts.shift]
      end
      parts[0]
    end
  end

  def alternative(*parts)
    case parts.size
    when 0
      raise "Can't have empty alternative"
    when 1
      parts[0]
    else
      while parts.size > 1
        parts.unshift [:alt, parts.shift, parts.shift]
      end
      parts[0]
    end
  end

  # Saves us time to reuse ruby regexp engine for 1 character case
  def character_type(char_rx)
    char_rx = Regexp.new(char_rx)
    codes = (0..127).select{|c| c.chr =~ char_rx}
    [:set, codes]
  end

  def character_set(negated, members)
    if negated
      character_type "[^#{members.join}]"
    else
      character_type "[#{members.join}]"
    end
  end

  def literal(chars)
    sequence(*chars.map{|c| character_type(c)})
  end

  def star(part)
    [:star, part]
  end

  # Try to express regexps with minimum number of primitives:
  # * seq  - ab
  # * alt  - a|b
  # * star - a*
  # * set  - a [a-z] [^a-z]
  # * empty
  def parse(node=@tree)
    result = case node
    when Regexp::Expression::Alternation
      alternative(*node.expressions.map{|n| parse(n)})
    when Regexp::Expression::Subexpression
      sequence(*node.expressions.map{|n| parse(n)})
    when Regexp::Expression::CharacterSet
      character_set(node.negative?, node.members)
    when Regexp::Expression::Literal
      literal(node.text.chars)
    when Regexp::Expression::CharacterType::Base
      character_type(node.text)
    else
      binding.pry
    end
    if node.quantified?
      min = node.quantifier.min
      max = node.quantifier.max
      if max == -1
        result = sequence(*([result]*min), star(result))
      else
        maybe_result = alternative([:empty], result)
        result = sequence(*([result]*min), *([maybe_result] * (max-min)))
      end
    end
    result
  end
end
