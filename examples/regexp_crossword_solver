#!/usr/bin/env ruby

require_relative "../lib/z3"
require "pathname"
require "regexp_parser"
require "set"
require "pry"

# Format generated by Regexp::Parser is not convenient at all,
# let's translate it into something more useful
class RegexpParser
  def initialize(str)
    @tree = Regexp::Parser.parse(str)
  end

  def sequence(*parts)
    parts = parts.select{|x| x[0] != :empty}
    case parts.size
    when 0
      [:empty]
    when 1
      parts[0]
    else
      while parts.size > 1
        parts << [:seq, parts.pop, parts.pop]
      end
      parts[0]
    end
  end

  def alternative(*parts)
    case parts.size
    when 0
      raise "Can't have empty alternative"
    when 1
      parts[0]
    else
      while parts.size > 1
        parts << [:alt, parts.pop, parts.pop]
      end
      parts[0]
    end
  end

  def character_set(negated, members)
    codes = []
    members.each do |m|
      if m.size == 1
        codes << m.ord
      elsif m.size == 3 and m[1] == "-"
        binding.pry
      else
        raise "Can't parse #{m} in character set"
      end
    end
    if negated
      [:neg_set, codes]
    else
      [:set, codes]
    end
  end

  def literal(chars)
    sequence(*chars.map{|c| character_set(false, [c])})
  end

  def star(part)
    [:star, part]
  end

  # Try to express regexps with minimum number of primitives:
  # * seq  - ab
  # * alt  - a|b
  # * star - a*
  # * set  - a [a-z] [^a-z]
  # * empty
  def parse(node=@tree)
    result = case node
    when Regexp::Expression::Alternation
      alternative(*node.expressions.map{|n| parse(n)})
    when Regexp::Expression::Subexpression
      sequence(*node.expressions.map{|n| parse(n)})
    when Regexp::Expression::CharacterSet
      character_set(node.negative?, node.members)
    when Regexp::Expression::Literal
      literal(node.text.chars)
    else
      binding.pry
    end
    if node.quantified?
      min = node.quantifier.min
      max = node.quantifier.max
      if max == -1
        result = sequence(*([result]*min), star(result))
      else
        maybe_result = alternative([:empty], result)
        result = sequence(*([result]*min), *([maybe_result] * (max-min)))
      end
    end
    result
  end
end

class RegexpCrosswordSolver
  def initialize(path)
    data = Pathname(path).read
    data = data.strip.split("\n")
    col_number = data.index("")
    row_number = data.size - col_number - 1
    # left to right
    @cols = data.first(col_number)
    # top to bottom
    @rows = data.last(row_number)
    @solver = Z3::Solver.new
    @xsize = @cols.size
    @ysize = @rows.size
  end

  def setup_cell(x,y)
    v = Z3.Int("cell#{x},#{y}")
    @solver.assert v >= 0
    @solver.assert v <= 127
    v
  end

  # @subexprs just prevents loops for self-referential regexps
  def regexp_match(rx, str)
    var = Z3.Bool("#{rx} =~ #{str}".hash.abs.to_s)
    return var if @subexprs.include?(var)
    @subexprs << var
    case rx[0]
    when :seq
      rx_a, rx_b = rx[1], rx[2]
      possibilities = (0..str.size).map do |i|
        a, b = str[0...i], str[i..-1]
        a_ok = regexp_match(rx_a, a)
        b_ok = regexp_match(rx_b, b)
        a_ok & b_ok
      end
      @solver.assert var == Z3.Or(*possibilities)
    when :set
      if str.size == 1
        @solver.assert var == Z3.Or(*rx[1].map{|c| str[0] == c })
      else
        @solver.assert var == false
      end
    when :neg_set
      if str.size == 1
        @solver.assert var == ~Z3.Or(*rx[1].map{|c| str[0] == c })
      else
        @solver.assert var == false
      end
    when :alt
      rx_a, rx_b = rx[1], rx[2]
      a_ok = regexp_match(rx_a, str)
      b_ok = regexp_match(rx_b, str)
      @solver.assert var == (a_ok | b_ok)
    when :star
      if str.size == 0
        @solver.assert var == true
      else
        r = rx[1]
        possibilities = (1..str.size).map do |i|
          a, b = str[0...i], str[i..-1]
          a_ok = regexp_match(r, a)
          b_ok = regexp_match(rx, b)
          a_ok & b_ok
        end
        @solver.assert var == Z3.Or(*possibilities)
      end
    else
      binding.pry
    end
    var
  end

  def setup_regexp(rx,str)
    @subexprs = Set[]
    rx = RegexpParser.new(rx).parse
    @solver.assert regexp_match(rx, str)
  end

  def solve!
    @crossword = {}
    @xsize.times do |x|
      @ysize.times do |y|
        @crossword[[x,y]] = setup_cell(x,y)
      end
    end

    @xsize.times do |x|
      setup_regexp @cols[x], (0...@ysize).map{|y| @crossword[[x,y]]}
    end
    @ysize.times do |y|
      setup_regexp @rows[y], (0...@xsize).map{|x| @crossword[[x,y]]}
    end

    print_answer
  end

  def print_answer
    if @solver.satisfiable?
      @model = @solver.model
      @ysize.times do |y|
        puts @xsize.times.map{|x|
          @model[@crossword[[x,y]]].to_i.chr
        }.join
      end
    else
      binding.pry
      print "Crossword has no solution"
    end
  end
end

path = ARGV[0] || Pathname(__dir__) + "regexp_crossword/tutorial-1.txt"
RegexpCrosswordSolver.new(path).solve!
