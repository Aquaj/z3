#!/usr/bin/env ruby

require_relative "../lib/z3"
require "pathname"
require "set"
require "pry"
require_relative "simple_regexp_parser"

class RegexpCrosswordSolver
  def initialize(path)
    data = Pathname(path).read
    data = data.strip.split("\n")
    col_number = data.index("")
    row_number = data.size - col_number - 1
    # left to right
    @cols = data.first(col_number)
    # top to bottom
    @rows = data.last(row_number)
    @solver = Z3::Solver.new
    @xsize = @cols.size
    @ysize = @rows.size
  end

  def setup_cell(x,y)
    v = Z3.Int("cell#{x},#{y}")
    @solver.assert v >= 0
    @solver.assert v <= 127
    v
  end

  def group_equal(group_identifier, str)
    Z3.And(
      Z3.Int("group-#{group_identifier}-size") == str.size,
      *str.each_with_index.map{|s,i| Z3.Int("group-#{group_identifier}-char[#{i}]") == s }
    )
  end

  # @subexprs just prevents loops for self-referential regexps
  def regexp_match(rx, str)
    var = Z3.Bool("#{rx} =~ #{str}")
    return var if @subexprs.include?(var)
    @subexprs << var
    case rx[0]
    when :seq
      rx_a, rx_b = rx[1], rx[2]
      possibilities = (0..str.size).map do |i|
        a, b = str[0...i], str[i..-1]
        a_ok = regexp_match(rx_a, a)
        b_ok = regexp_match(rx_b, b)
        a_ok & b_ok
      end
      @solver.assert var == Z3.Or(*possibilities)
    when :set
      if str.size == 1
        @solver.assert var == Z3.Or(*rx[1].map{|c| str[0] == c })
      else
        @solver.assert var == false
      end
    when :neg_set
      if str.size == 1
        @solver.assert var == ~Z3.Or(*rx[1].map{|c| str[0] == c })
      else
        @solver.assert var == false
      end
    when :alt
      rx_a, rx_b = rx[1], rx[2]
      a_ok = regexp_match(rx_a, str)
      b_ok = regexp_match(rx_b, str)
      @solver.assert var == (a_ok | b_ok)
    when :star
      if str.size == 0
        @solver.assert var == true
      else
        r = rx[1]
        possibilities = (1..str.size).map do |i|
          a, b = str[0...i], str[i..-1]
          a_ok = regexp_match(r, a)
          b_ok = regexp_match(rx, b)
          a_ok & b_ok
        end
        @solver.assert var == Z3.Or(*possibilities)
      end
    when :group
      n = rx[1]
      rx_a = rx[2]
      @solver.assert var == (regexp_match(rx_a, str) & group_equal(n, str))
    when :backref
      @solver.assert var == group_equal(rx[1], str)
    when :empty
      @solver.assert var == (str.size == 0)
    else
      raise "Unknown regexp type #{rx[0]}"
    end
    var
  end

  def col_str(x)
    (0...@ysize).map{|y| @crossword[[x,y]]}
  end

  def row_str(y)
    (0...@xsize).map{|x| @crossword[[x,y]]}
  end

  def col_rx(x)
    SimpleRegexpParser.new(@cols[x], "col-#{x}").parse
  end

  def row_rx(y)
    SimpleRegexpParser.new(@rows[y], "row-#{y}").parse
  end

  def solve!
    @crossword = {}
    @xsize.times do |x|
      @ysize.times do |y|
        @crossword[[x,y]] = setup_cell(x,y)
      end
    end

    @subexprs = Set[]
    @xsize.times do |x|
      @solver.assert regexp_match(col_rx(x), col_str(x))
    end
    @ysize.times do |y|
      @solver.assert regexp_match(row_rx(y), row_str(y))
    end

    print_answer
  end

  def print_answer
    if @solver.satisfiable?
      @model = @solver.model
      @ysize.times do |y|
        puts @xsize.times.map{|x|
          @model[@crossword[[x,y]]].to_i.chr
        }.join.inspect[1...-1]
      end
    else
      raise
      print "Crossword has no solution"
    end
  end
end

path = ARGV[0] || Pathname(__dir__) + "regexp_crossword/tutorial-1.txt"
RegexpCrosswordSolver.new(path).solve!
