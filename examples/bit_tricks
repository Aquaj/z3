#!/usr/bin/env ruby

require_relative "../lib/z3"

def validate_sign_by_shift!
  """
  sign = v >> (sizeof(int) * CHAR_BIT - 1);
  """
  solver = Z3::Solver.new
  v = Z3.Bitvec("v", 32)
  s = v >> 31
  puts "Validating sign trick:"
  solver.prove! ((v < 0) & (s == -1)) | ((v >= 0) & (s == 0))
end

def validate_opposite_sign_by_xor!
  """
  int x, y;               // input values to compare signs
  bool f = ((x ^ y) < 0); // true iff x and y have opposite signs
  """
  solver = Z3::Solver.new
  x = Z3.Bitvec("x", 32)
  y = Z3.Bitvec("y", 32)
  f = (x^y) < 0

  puts "Validating sign trick:"
  solver.prove!(
    Z3.Or(
      Z3.And(x >= 0, y >= 0, f == false),
      Z3.And(x < 0, y < 0, f == false),
      Z3.And(x >= 0, y < 0, f == true),
      Z3.And(x < 0, y >= 0, f == true),
    )
  )
end

def validate_abs_without_branching_1!
  """
  int v;           // we want to find the absolute value of v
  unsigned int r;  // the result goes here
  int const mask = v >> sizeof(int) * CHAR_BIT - 1;
  r = (v + mask) ^ mask;
  """
  solver = Z3::Solver.new
  v = Z3.Bitvec("v", 32)
  mask = v >> 31
  r = (v + mask) ^ mask
  puts "Validating abs without branching, version 1"
  solver.prove!(
    Z3.Or(
      Z3.And(v >= 0, r==v),
      Z3.And(v < 0, r==-v)
    )
  )
end

def validate_abs_without_branching_2!
  """
  int v;           // we want to find the absolute value of v
  unsigned int r;  // the result goes here
  int const mask = v >> sizeof(int) * CHAR_BIT - 1;
  r = (v ^ mask) - mask;
  """
  solver = Z3::Solver.new
  v = Z3.Bitvec("v", 32)
  mask = v >> 31
  r = (v^mask) - mask
  puts "Validating abs without branching, version 2"
  solver.prove!(
    Z3.Or(
      Z3.And(v >= 0, r==v),
      Z3.And(v < 0, r==-v)
    )
  )
end

validate_sign_by_shift!
validate_opposite_sign_by_xor!
validate_abs_without_branching_1!
validate_abs_without_branching_2!

"""
Based on https://graphics.stanford.edu/~seander/bithacks.html
"""
